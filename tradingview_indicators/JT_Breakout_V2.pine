// This Pine Script™ is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © JustTrades Group, Inc.
//
// ╔══════════════════════════════════════════════════════════════════════════╗
// ║  JustTrades Breakout V.2 — Dual SMMA Crossover + ATR Bands            ║
// ║                                                                        ║
// ║  Run on 1-min chart (regular or Heikin Ashi).                          ║
// ║                                                                        ║
// ║  V2 REDESIGN:                                                          ║
// ║  V1's Fib band breakout entries chased extended moves. By the time     ║
// ║  price crossed the outer band, the move was often exhausted.           ║
// ║  613 trades, 41% WR, -$17,842 — strategy fundamentally broken.        ║
// ║                                                                        ║
// ║  V2 replaces the entry engine with a DUAL SMMA crossover system:      ║
// ║  • Fast SMMA (8) reacts to momentum shifts quickly                     ║
// ║  • Slow SMMA (21) provides trend direction / support-resistance       ║
// ║  • Cross = trend shift → ENTRY early in the move, not at the end      ║
// ║  • ATR bands kept as dynamic TP/SL reference + visual context          ║
// ║  • Slope filter ensures we only trade when trend is actually moving    ║
// ║                                                                        ║
// ║  CRITICAL: fill_orders_on_standard_ohlc = true                         ║
// ║  EXIT DECISION MATRIX: strategy.exit() for all price-level exits       ║
// ║  REALISM MODE: fill delay + 8-tick slippage + stale cancellation       ║
// ╚══════════════════════════════════════════════════════════════════════════╝

//@version=5
strategy("JustTrades Breakout V.2",
     overlay              = true,
     initial_capital      = 10000,
     default_qty_type     = strategy.fixed,
     default_qty_value    = 1,
     commission_type      = strategy.commission.cash_per_contract,
     commission_value     = 0.82,
     slippage             = 8,
     pyramiding           = 0,
     calc_on_every_tick   = false,
     process_orders_on_close = false,
     fill_orders_on_standard_ohlc = true,
     use_bar_magnifier    = true)

// ─────────────────────────────────────────────────────────────
// GROUP: Realism Mode
// ─────────────────────────────────────────────────────────────
g_real = "Realism Mode"
useRealism     = input.bool(true, "Enable Realism Mode", group=g_real, tooltip="Master switch. Applies fill delay for realistic webhook latency. Turn OFF to see raw strategy edge.")
fillDelayBars  = input.int(1, "Fill Delay (bars)", minval=0, maxval=5, group=g_real, tooltip="Bars to wait after signal before entering. 1 = conservative for 1-min chart.")
cancelStale    = input.bool(true, "Cancel Stale Signals", group=g_real, tooltip="Cancel pending entry if SMMA cross reverses, session ends, or daily limit hit during delay.")

// ─────────────────────────────────────────────────────────────
// GROUP: Dual SMMA Engine
// ─────────────────────────────────────────────────────────────
g_smma = "Dual SMMA Engine"
fastLen  = input.int(8, "Fast SMMA Length", minval=3, maxval=50, group=g_smma,
     tooltip="Shorter period = faster reaction to price changes. Catches momentum shifts early. 8 is responsive without being noisy on 1-min MNQ.")
slowLen  = input.int(21, "Slow SMMA Length", minval=10, maxval=200, group=g_smma,
     tooltip="Longer period = smoother trend line. Acts as dynamic support/resistance. 21 is ~1 trading day lookback on 1-min chart during RTH.")
src      = input.source(close, "Price Source", group=g_smma,
     tooltip="Price source for both SMMA lines. 'close' is standard. 'hl2' is smoother.")

// ─────────────────────────────────────────────────────────────
// GROUP: Entry Mode
// ─────────────────────────────────────────────────────────────
g_entry = "Entry Mode"
entryMode = input.string("SMMA Cross", "Entry Trigger",
     options=["SMMA Cross", "Cross + Close Confirm", "Cross + Pullback"],
     group=g_entry,
     tooltip="SMMA Cross: enter on fast/slow crossover (earliest). Cross + Close Confirm: wait for bar to close beyond both lines. Cross + Pullback: after cross, wait for price to retest slow SMMA then bounce.")
useSlope   = input.bool(true, "Slope Filter", group=g_entry,
     tooltip="Only trade when slow SMMA has meaningful slope (trending, not flat). Avoids chop zones where crosses whipsaw.")
slopeBars  = input.int(5, "Slope Lookback (bars)", minval=2, maxval=20, group=g_entry,
     tooltip="How many bars to measure slow SMMA slope over. Lower = more responsive, higher = stricter trend requirement.")
slopeMin   = input.float(0.5, "Min Slope (pts)", minval=0.1, maxval=10.0, step=0.1, group=g_entry,
     tooltip="Minimum absolute price change in slow SMMA over lookback bars. 0.5 pts on MNQ = 2 ticks. Filters dead-flat chop.")
priceSide  = input.bool(true, "Price Must Be On Correct Side", group=g_entry,
     tooltip="Longs: close must be above slow SMMA. Shorts: close must be below. Prevents false crosses where price hasn't actually broken through.")

// ─────────────────────────────────────────────────────────────
// GROUP: ATR Bands (visual context + optional dynamic exits)
// ─────────────────────────────────────────────────────────────
g_bands = "ATR Bands"
atrLen     = input.int(14, "ATR Length", minval=5, maxval=200, group=g_bands,
     tooltip="ATR period for band width. 14 is standard.")
bandMult   = input.float(1.5, "Band Multiplier", minval=0.5, maxval=5.0, step=0.1, group=g_bands,
     tooltip="Width of bands around slow SMMA. 1.5 ATR = one standard deviation zone. Bands serve as dynamic TP/SL reference.")
showBands  = input.bool(true, "Show ATR Bands", group=g_bands)

// ─────────────────────────────────────────────────────────────
// GROUP: Exit Mode
// ─────────────────────────────────────────────────────────────
g_exit = "Exit Mode"
exitTarget = input.string("Fixed Ticks", "Take Profit Target",
     options=["ATR Band", "Fixed Ticks", "None (Trail/BE Only)"],
     group=g_exit,
     tooltip="Fixed Ticks recommended for MNQ. ATR Band uses the upper/lower band as dynamic TP. None relies on trail/BE only.")
fixedTP    = input.int(100, "Fixed TP (ticks)", minval=1, maxval=2000, group=g_exit,
     tooltip="100 ticks = 25 pts MNQ. Captures meaningful moves without overholding.")
exitStop   = input.string("Fixed Ticks", "Stop Loss Level",
     options=["ATR Band", "Slow SMMA", "Fixed Ticks"],
     group=g_exit,
     tooltip="Fixed Ticks for controlled risk. ATR Band uses opposite band. Slow SMMA = tight stop at the trend line.")
fixedSL    = input.int(60, "Fixed SL (ticks)", minval=1, maxval=2000, group=g_exit,
     tooltip="60 ticks = 15 pts MNQ. R:R = 100/60 = 1.67. Only needs 37.5% WR to breakeven.")

// ─────────────────────────────────────────────────────────────
// GROUP: Risk Management
// ─────────────────────────────────────────────────────────────
g_risk = "Risk Management"
useTrailing   = input.bool(false, "Enable Trailing Stop", group=g_risk,
     tooltip="Add a trailing stop that activates after reaching profit threshold.")
trailTicks    = input.int(30, "Trail Offset (ticks)", minval=1, maxval=200, group=g_risk)
trailActTicks = input.int(40, "Trail Activation (ticks in profit)", minval=0, maxval=200, group=g_risk)
useBE         = input.bool(true, "Enable Breakeven Stop", group=g_risk,
     tooltip="Moves stop to entry + offset once profit threshold reached. Converts losing reversals into small wins.")
beTicks       = input.int(30, "BE Activation (ticks in profit)", minval=1, maxval=100, group=g_risk,
     tooltip="30 ticks = 7.5 pts MNQ. Trade must prove itself before BE kicks in.")
beOffset      = input.int(2, "BE Offset (ticks past entry)", minval=0, maxval=20, group=g_risk,
     tooltip="Lock in 2 ticks when BE activates.")
maxDailyLoss  = input.float(150, "Max Daily Loss ($, 0=off)", minval=0, step=50, group=g_risk,
     tooltip="$150 daily kill switch.")
maxTrades     = input.int(10, "Max Trades Per Day (0=off)", minval=0, maxval=100, group=g_risk,
     tooltip="10 max. Forces quality over quantity.")

// ─────────────────────────────────────────────────────────────
// GROUP: Session Filter
// ─────────────────────────────────────────────────────────────
g_sess = "Session Filter"
useSessFilter = input.bool(true, "Enable Session Filter", group=g_sess,
     tooltip="ON by default. Overnight trades are noise on MNQ.")
sessStart     = input.session("0800-1430", "Trading Session (Exchange TZ)", group=g_sess,
     tooltip="08:00-14:30 CT. Catches morning momentum, avoids close chop.")
sessTimezone  = input.string("America/Chicago", "Session Timezone",
     options=["America/Chicago", "America/New_York", "America/Los_Angeles", "UTC"],
     group=g_sess)
noFridayPM    = input.bool(true, "No Entries Friday After 12:00", group=g_sess)
closeEOD      = input.bool(true, "Flatten at Session Close", group=g_sess,
     tooltip="Close any open position at session end.")

// ─────────────────────────────────────────────────────────────
// GROUP: Signal Filters
// ─────────────────────────────────────────────────────────────
g_filt = "Signal Filters"
useVolFilter = input.bool(false, "Volume Filter", group=g_filt,
     tooltip="Only take crosses when volume confirms the move.")
volMaLen     = input.int(20, "Volume MA Length", minval=5, maxval=100, group=g_filt)
volMult      = input.float(1.2, "Volume Threshold (x MA)", minval=0.5, maxval=5.0, step=0.1, group=g_filt)
useAtrFilter = input.bool(false, "ATR Volatility Filter", group=g_filt,
     tooltip="Only trade when volatility is above minimum.")
atrFilterLen = input.int(14, "ATR Filter Length", minval=5, maxval=100, group=g_filt)
atrMinTicks  = input.float(5.0, "Min ATR (ticks)", minval=0.5, maxval=50, step=0.5, group=g_filt)
cooldownBars = input.int(5, "Cooldown After Exit (bars, 0=off)", minval=0, maxval=50, group=g_filt,
     tooltip="5 bars between trades to avoid re-entering chop.")

// ─────────────────────────────────────────────────────────────
// GROUP: Visuals
// ─────────────────────────────────────────────────────────────
g_vis = "Visuals"
showLabels = input.bool(true, "Show Entry Labels", group=g_vis)
showTable  = input.bool(true, "Show Info Table", group=g_vis)
showFill   = input.bool(true, "Show SMMA Zone Fill", group=g_vis)
fastColor  = input.color(color.new(#2196F3, 0), "Fast SMMA Color", group=g_vis)
slowColor  = input.color(color.new(#FF9800, 0), "Slow SMMA Color", group=g_vis)
bandColor  = input.color(color.new(color.gray, 70), "Band Color", group=g_vis)
longLblColor  = input.color(color.new(color.teal, 0), "Long Label Color", group=g_vis)
shortLblColor = input.color(color.new(color.red, 0), "Short Label Color", group=g_vis)

// ─────────────────────────────────────────────────────────────
// CORE CALCULATIONS — DUAL SMMA
// ─────────────────────────────────────────────────────────────
smma(source, length) =>
    var float v = na
    sma = ta.sma(source, length)
    v := na(v[1]) ? sma : (v[1] * (length - 1) + source) / length
    v

fastSMMA = smma(src, fastLen)
slowSMMA = smma(src, slowLen)

// ATR bands around the slow SMMA
atrVal    = ta.atr(atrLen)
upperBand = slowSMMA + atrVal * bandMult
lowerBand = slowSMMA - atrVal * bandMult

// Slope of slow SMMA (is it actually trending or flat?)
slowSlope = slowSMMA - slowSMMA[slopeBars]
slopeOK   = not useSlope or math.abs(slowSlope) >= slopeMin

// SMMA relationship
fastAboveSlow = fastSMMA > slowSMMA
fastBelowSlow = fastSMMA < slowSMMA

// ─────────────────────────────────────────────────────────────
// SESSION & FILTER LOGIC
// ─────────────────────────────────────────────────────────────
inSession = useSessFilter ? not na(time(timeframe.period, sessStart, sessTimezone)) : true
isFridayPM = noFridayPM and dayofweek == dayofweek.friday and hour >= 12
sessionOK = inSession and not isFridayPM

// Volume filter
volMA = ta.sma(volume, volMaLen)
volOK = useVolFilter ? (volume > volMA * volMult) : true

// ATR filter
atrFilter = ta.atr(atrFilterLen)
atrOK = useAtrFilter ? (atrFilter >= atrMinTicks * syminfo.mintick) : true

// Cooldown tracking
var int barsSinceExit = 999
if strategy.closedtrades > 0 and strategy.closedtrades != strategy.closedtrades[1]
    barsSinceExit := 0
else
    barsSinceExit += 1
cooldownOK = cooldownBars == 0 or barsSinceExit >= cooldownBars

// Daily trade count
var int dailyTrades = 0
if ta.change(time("D"))
    dailyTrades := 0
if strategy.closedtrades > strategy.closedtrades[1]
    dailyTrades += 1
tradeCountOK = maxTrades == 0 or dailyTrades < maxTrades

// Daily loss tracking
var float dailyStartEquity = strategy.equity
if ta.change(time("D"))
    dailyStartEquity := strategy.equity
dailyPnL = strategy.equity - dailyStartEquity
dailyLossOK = maxDailyLoss == 0 or dailyPnL > -maxDailyLoss

baseFilters = sessionOK and volOK and atrOK and cooldownOK and tradeCountOK and dailyLossOK

// ─────────────────────────────────────────────────────────────
// ENTRY SIGNAL GENERATION — DUAL SMMA CROSSOVER
// ─────────────────────────────────────────────────────────────

// Raw crossover detection
bullCross = ta.crossover(fastSMMA, slowSMMA)
bearCross = ta.crossunder(fastSMMA, slowSMMA)

// Price-side confirmation
priceAboveSlow = close > slowSMMA
priceBelowSlow = close < slowSMMA
priceLongOK  = not priceSide or priceAboveSlow
priceShortOK = not priceSide or priceBelowSlow

// --- Entry Mode: SMMA Cross (simplest — enter on cross bar) ---
bool crossLong  = false
bool crossShort = false

if entryMode == "SMMA Cross"
    crossLong  := bullCross
    crossShort := bearCross

// --- Entry Mode: Cross + Close Confirm ---
// Wait for a bar to CLOSE with price above both lines (long) or below both (short)
// after the cross occurred
else if entryMode == "Cross + Close Confirm"
    var bool awaitLongConfirm  = false
    var bool awaitShortConfirm = false

    if bullCross
        awaitLongConfirm  := true
        awaitShortConfirm := false
    if bearCross
        awaitShortConfirm := true
        awaitLongConfirm  := false

    // Confirm: close above BOTH lines
    if awaitLongConfirm and close > fastSMMA and close > slowSMMA
        crossLong := true
        awaitLongConfirm := false
    // Invalidate if fast crosses back below
    if awaitLongConfirm and fastSMMA < slowSMMA
        awaitLongConfirm := false

    if awaitShortConfirm and close < fastSMMA and close < slowSMMA
        crossShort := true
        awaitShortConfirm := false
    if awaitShortConfirm and fastSMMA > slowSMMA
        awaitShortConfirm := false

// --- Entry Mode: Cross + Pullback ---
// After cross, wait for price to pull back to slow SMMA and bounce
else if entryMode == "Cross + Pullback"
    var bool waitLongPullback  = false
    var bool waitShortPullback = false

    if bullCross
        waitLongPullback  := true
        waitShortPullback := false
    if bearCross
        waitShortPullback := true
        waitLongPullback  := false

    // Pullback: price touches slow SMMA then closes above it
    if waitLongPullback and low <= slowSMMA and close > slowSMMA and fastAboveSlow
        crossLong := true
        waitLongPullback := false
    // Invalidate if cross reverses
    if waitLongPullback and fastBelowSlow
        waitLongPullback := false

    if waitShortPullback and high >= slowSMMA and close < slowSMMA and fastBelowSlow
        crossShort := true
        waitShortPullback := false
    if waitShortPullback and fastAboveSlow
        waitShortPullback := false

// Final raw entry conditions
rawLongCond  = crossLong and slopeOK and priceLongOK and baseFilters
rawShortCond = crossShort and slopeOK and priceShortOK and baseFilters

// ─────────────────────────────────────────────────────────────
// FILL DELAY SYSTEM (Realism)
// ─────────────────────────────────────────────────────────────

var bool pendingLong  = false
var bool pendingShort = false
var int  signalBar    = 0

int effectiveDelay = useRealism ? fillDelayBars : 0

if rawLongCond and not pendingLong
    if effectiveDelay == 0
        pendingLong := false
    else
        pendingLong  := true
        pendingShort := false
        signalBar    := bar_index

if rawShortCond and not pendingShort
    if effectiveDelay == 0
        pendingShort := false
    else
        pendingShort := true
        pendingLong  := false
        signalBar    := bar_index

// Cancel stale signals — cross reversed or filters failed during delay
if cancelStale and useRealism
    if pendingLong and (not sessionOK or not dailyLossOK or not tradeCountOK or fastBelowSlow)
        pendingLong := false
    if pendingShort and (not sessionOK or not dailyLossOK or not tradeCountOK or fastAboveSlow)
        pendingShort := false

// Check delay elapsed
bool delayLong  = pendingLong and bar_index >= signalBar + effectiveDelay
bool delayShort = pendingShort and bar_index >= signalBar + effectiveDelay

// Final entry conditions
bool longCond  = (rawLongCond and effectiveDelay == 0) or delayLong
bool shortCond = (rawShortCond and effectiveDelay == 0) or delayShort

// ─────────────────────────────────────────────────────────────
// STOP & TARGET CALCULATION
// ─────────────────────────────────────────────────────────────

getLongStop() =>
    switch exitStop
        "ATR Band"    => lowerBand
        "Slow SMMA"   => slowSMMA
        "Fixed Ticks" => strategy.position_avg_price - (fixedSL * syminfo.mintick)

getShortStop() =>
    switch exitStop
        "ATR Band"    => upperBand
        "Slow SMMA"   => slowSMMA
        "Fixed Ticks" => strategy.position_avg_price + (fixedSL * syminfo.mintick)

getLongTarget() =>
    switch exitTarget
        "ATR Band"           => upperBand
        "Fixed Ticks"        => strategy.position_avg_price + (fixedTP * syminfo.mintick)
        "None (Trail/BE Only)" => na

getShortTarget() =>
    switch exitTarget
        "ATR Band"           => lowerBand
        "Fixed Ticks"        => strategy.position_avg_price - (fixedTP * syminfo.mintick)
        "None (Trail/BE Only)" => na

// ─────────────────────────────────────────────────────────────
// ORDER EXECUTION
// ─────────────────────────────────────────────────────────────
if longCond
    strategy.entry("L", strategy.long)
    pendingLong := false

if shortCond
    strategy.entry("S", strategy.short)
    pendingShort := false

// Exit logic — layered: trailing > breakeven > fixed
// All exits use strategy.exit() — fills at exact price intra-bar
if strategy.position_size > 0
    entryPx   = strategy.position_avg_price
    profitTks = (close - entryPx) / syminfo.mintick

    stopPx  = getLongStop()
    limitPx = getLongTarget()

    if useTrailing and profitTks >= trailActTicks
        strategy.exit("LX", from_entry="L", trail_points=trailActTicks, trail_offset=trailTicks,
             limit=na(limitPx) ? na : limitPx)
    else if useBE and profitTks >= beTicks
        beStop = entryPx + (beOffset * syminfo.mintick)
        strategy.exit("LX", from_entry="L", stop=beStop, limit=na(limitPx) ? na : limitPx)
    else
        strategy.exit("LX", from_entry="L", stop=stopPx, limit=na(limitPx) ? na : limitPx)

if strategy.position_size < 0
    entryPx   = strategy.position_avg_price
    profitTks = (entryPx - close) / syminfo.mintick

    stopPx  = getShortStop()
    limitPx = getShortTarget()

    if useTrailing and profitTks >= trailActTicks
        strategy.exit("SX", from_entry="S", trail_points=trailActTicks, trail_offset=trailTicks,
             limit=na(limitPx) ? na : limitPx)
    else if useBE and profitTks >= beTicks
        beStop = entryPx - (beOffset * syminfo.mintick)
        strategy.exit("SX", from_entry="S", stop=beStop, limit=na(limitPx) ? na : limitPx)
    else
        strategy.exit("SX", from_entry="S", stop=stopPx, limit=na(limitPx) ? na : limitPx)

// --- Flatten at session close ---
if closeEOD and useSessFilter
    if na(time(timeframe.period, sessStart, sessTimezone)) and not na(time(timeframe.period, sessStart, sessTimezone)[1])
        strategy.close_all(comment="EOD Flat")

// ─────────────────────────────────────────────────────────────
// PLOTS
// ─────────────────────────────────────────────────────────────

// Dual SMMA lines — the core of V2
pFast = plot(fastSMMA, "Fast SMMA", fastColor, 2)
pSlow = plot(slowSMMA, "Slow SMMA", slowColor, 2)

// Fill between SMMA lines — green when fast > slow (bullish), red when fast < slow (bearish)
smmaFillColor = fastAboveSlow ? color.new(color.teal, 85) : color.new(color.red, 85)
fill(pFast, pSlow, showFill ? smmaFillColor : na, "SMMA Trend Zone")

// ATR bands around slow SMMA
plot(showBands ? upperBand : na, "Upper Band", bandColor, 1, style=plot.style_linebr)
plot(showBands ? lowerBand : na, "Lower Band", bandColor, 1, style=plot.style_linebr)

// Cross markers — the actual signal points
plotshape(bullCross, "Bull Cross", shape.circle, location.belowbar, color.new(color.teal, 0), size=size.tiny)
plotshape(bearCross, "Bear Cross", shape.circle, location.abovebar, color.new(color.red, 0), size=size.tiny)

// Entry labels — show raw entry signal (before delay)
if showLabels and rawLongCond
    label.new(bar_index, low, "▲ LONG", style=label.style_label_up,
         color=longLblColor, textcolor=color.white, size=size.tiny)
if showLabels and rawShortCond
    label.new(bar_index, high, "▼ SHORT", style=label.style_label_down,
         color=shortLblColor, textcolor=color.white, size=size.tiny)

// Delayed fill markers
plotshape(delayLong, "Delayed Long Fill", shape.diamond, location.belowbar, color.new(color.teal, 0), size=size.tiny, text="FILL")
plotshape(delayShort, "Delayed Short Fill", shape.diamond, location.abovebar, color.new(color.red, 0), size=size.tiny, text="FILL")

// Pending signal markers
plotshape(pendingLong, "Pending Long", shape.circle, location.belowbar, color.new(color.yellow, 50), size=size.tiny)
plotshape(pendingShort, "Pending Short", shape.circle, location.abovebar, color.new(color.yellow, 50), size=size.tiny)

// Slope rejection marker (cross happened but slope too flat)
plotshape(bullCross and not slopeOK, "Flat Slope Reject (Bull)", shape.xcross, location.belowbar, color.new(color.gray, 30), size=size.tiny, text="FLAT")
plotshape(bearCross and not slopeOK, "Flat Slope Reject (Bear)", shape.xcross, location.abovebar, color.new(color.gray, 30), size=size.tiny, text="FLAT")

// ─────────────────────────────────────────────────────────────
// INFO TABLE
// ─────────────────────────────────────────────────────────────
if showTable and barstate.islast
    var table infoTbl = table.new(position.top_right, 2, 13,
         bgcolor=color.new(color.black, 80), border_color=color.new(color.gray, 60), border_width=1)

    table.cell(infoTbl, 0, 0, "Strategy", text_color=color.gray, text_size=size.small)
    table.cell(infoTbl, 1, 0, "BREAKOUT V2", text_color=color.blue, text_size=size.small)

    table.cell(infoTbl, 0, 1, "Realism", text_color=color.gray, text_size=size.small)
    string realText = useRealism ? "ON (" + str.tostring(fillDelayBars) + "bar)" : "OFF (raw)"
    table.cell(infoTbl, 1, 1, realText, text_color=useRealism ? color.yellow : color.gray, text_size=size.small)

    table.cell(infoTbl, 0, 2, "Entry Mode", text_color=color.gray, text_size=size.small)
    table.cell(infoTbl, 1, 2, entryMode, text_color=color.white, text_size=size.small)

    table.cell(infoTbl, 0, 3, "SMMA", text_color=color.gray, text_size=size.small)
    table.cell(infoTbl, 1, 3, str.tostring(fastLen) + " / " + str.tostring(slowLen), text_color=color.white, text_size=size.small)

    table.cell(infoTbl, 0, 4, "Trend", text_color=color.gray, text_size=size.small)
    table.cell(infoTbl, 1, 4, fastAboveSlow ? "BULL" : "BEAR",
         text_color=fastAboveSlow ? color.teal : color.red, text_size=size.small)

    table.cell(infoTbl, 0, 5, "Slope", text_color=color.gray, text_size=size.small)
    table.cell(infoTbl, 1, 5, slopeOK ? str.tostring(slowSlope, "#.##") + " pts" : "FLAT",
         text_color=slopeOK ? color.white : color.orange, text_size=size.small)

    table.cell(infoTbl, 0, 6, "TP / SL", text_color=color.gray, text_size=size.small)
    table.cell(infoTbl, 1, 6, exitTarget + " / " + exitStop, text_color=color.white, text_size=size.small)

    table.cell(infoTbl, 0, 7, "BE", text_color=color.gray, text_size=size.small)
    table.cell(infoTbl, 1, 7, useBE ? "ON @" + str.tostring(beTicks) + "t" : "OFF",
         text_color=useBE ? color.green : color.gray, text_size=size.small)

    table.cell(infoTbl, 0, 8, "Daily P&L", text_color=color.gray, text_size=size.small)
    table.cell(infoTbl, 1, 8, "$" + str.tostring(dailyPnL, "#.##"),
         text_color=dailyPnL >= 0 ? color.green : color.red, text_size=size.small)

    table.cell(infoTbl, 0, 9, "Trades Today", text_color=color.gray, text_size=size.small)
    table.cell(infoTbl, 1, 9, str.tostring(dailyTrades) + (maxTrades > 0 ? "/" + str.tostring(maxTrades) : ""),
         text_color=color.white, text_size=size.small)

    table.cell(infoTbl, 0, 10, "Session", text_color=color.gray, text_size=size.small)
    table.cell(infoTbl, 1, 10, sessionOK ? "ACTIVE" : "CLOSED",
         text_color=sessionOK ? color.green : color.red, text_size=size.small)

    table.cell(infoTbl, 0, 11, "Cooldown", text_color=color.gray, text_size=size.small)
    table.cell(infoTbl, 1, 11, cooldownOK ? "READY" : str.tostring(cooldownBars - barsSinceExit) + " bars",
         text_color=cooldownOK ? color.green : color.orange, text_size=size.small)

    table.cell(infoTbl, 0, 12, "Pending", text_color=color.gray, text_size=size.small)
    string pendText = pendingLong ? "LONG wait" : pendingShort ? "SHORT wait" : "---"
    table.cell(infoTbl, 1, 12, pendText,
         text_color=(pendingLong or pendingShort) ? color.yellow : color.gray, text_size=size.small)
