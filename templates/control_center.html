{% extends "layout.html" %}
{% block title %}Control Center - Just.Trades.{% endblock %}
{% block page_title %}CONTROL CENTER{% endblock %}
{% block content %}

{% if not has_platform_subscription %}
<!-- Platform Access Required Overlay -->
<div class="upgrade-overlay">
    <div class="upgrade-card">
        <div class="upgrade-icon">
            <span class="material-icons">lock</span>
        </div>
        <h2>Platform Access Required</h2>
        <p>You need a <strong>Platform subscription</strong> to access the Control Center. Discord subscriptions provide community access only.</p>
        <div class="upgrade-features">
            <div class="feature-item"><span class="material-icons">check_circle</span> Live trading panel</div>
            <div class="feature-item"><span class="material-icons">check_circle</span> Real-time P&L tracking</div>
            <div class="feature-item"><span class="material-icons">check_circle</span> Strategy management</div>
            <div class="feature-item"><span class="material-icons">check_circle</span> AutoTrader logs</div>
        </div>
        <div class="upgrade-buttons">
            <a href="/pricing" class="btn-upgrade">
                <span class="material-icons">rocket_launch</span>
                View Pricing Plans
            </a>
            <a href="/dashboard" class="btn-back">
                <span class="material-icons">arrow_back</span>
                Back to Dashboard
            </a>
        </div>
        <p class="current-tier">Your current plan: <strong>{% if subscription_status.tier == 'none' %}None{% else %}Discord Only{% endif %}</strong></p>
    </div>
</div>
<style>
    .upgrade-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(15, 23, 42, 0.95);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        padding: 20px;
    }
    .upgrade-card {
        background: linear-gradient(135deg, rgba(30, 41, 59, 0.95), rgba(15, 23, 42, 0.98));
        border: 1px solid rgba(25, 184, 255, 0.3);
        border-radius: 24px;
        padding: 48px;
        max-width: 520px;
        text-align: center;
        box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
    }
    .upgrade-icon {
        width: 80px;
        height: 80px;
        background: linear-gradient(135deg, rgba(25, 184, 255, 0.2), rgba(15, 136, 204, 0.1));
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        margin: 0 auto 24px;
    }
    .upgrade-icon .material-icons {
        font-size: 40px;
        color: var(--primary-color);
    }
    .upgrade-card h2 {
        font-size: 1.5rem;
        margin-bottom: 12px;
        color: var(--text-light);
    }
    .upgrade-card > p {
        color: var(--text-muted);
        margin-bottom: 24px;
        line-height: 1.6;
    }
    .upgrade-features {
        text-align: left;
        margin-bottom: 32px;
        padding: 20px;
        background: rgba(148, 163, 184, 0.05);
        border-radius: 12px;
    }
    .feature-item {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 8px 0;
        color: var(--text-light);
        font-size: 0.9rem;
    }
    .feature-item .material-icons {
        color: #22c55e;
        font-size: 20px;
    }
    .upgrade-buttons {
        display: flex;
        gap: 12px;
        justify-content: center;
        flex-wrap: wrap;
    }
    .btn-upgrade {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 14px 28px;
        background: linear-gradient(135deg, var(--primary-color), var(--primary-color-dark));
        color: white;
        border-radius: 12px;
        font-weight: 600;
        text-decoration: none;
        transition: all 0.2s ease;
    }
    .btn-upgrade:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 25px rgba(25, 184, 255, 0.4);
    }
    .btn-back {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 14px 28px;
        background: rgba(148, 163, 184, 0.15);
        color: var(--text-light);
        border-radius: 12px;
        font-weight: 600;
        text-decoration: none;
        transition: all 0.2s ease;
    }
    .btn-back:hover {
        background: rgba(148, 163, 184, 0.25);
    }
    .current-tier {
        margin-top: 24px;
        font-size: 0.85rem;
        color: var(--text-muted);
    }
</style>
{% endif %}

<div class="control-center">
    <section class="live-panels">
        <article class="live-trading">
            <header>
                <h2>Live Trading Panel</h2>
                <div class="panel-actions">
                    <button class="btn btn-danger" onclick="closeAllPositions()">
                        <span class="material-icons">close</span> Close All
                    </button>
                    <button class="btn btn-warning" onclick="clearAllTrades()">
                        <span class="material-icons">delete_sweep</span> Clear All
                    </button>
                    <button class="btn btn-outline" id="toggleAllBtn" onclick="toggleAllStrategies()">
                        <span class="material-icons">pause_circle</span> Disable All
                    </button>
                </div>
            </header>
            <div class="table-container">
            <table>
                <thead>
                    <tr>
                        <th>STRATEGY</th>
                            <th>STATUS</th>
                        <th>TIME FILTER</th>
                        <th>ACTIONS</th>
                    </tr>
                </thead>
                    <tbody id="tradersTableBody">
                        <!-- Will be populated by JavaScript with traders only -->
                        <tr>
                            <td colspan="4" class="loading-state">
                                <span class="material-icons spin">sync</span> Loading traders...
                        </td>
                    </tr>
                </tbody>
            </table>
            </div>
        </article>

        <article class="autotrader-logs">
            <header>
                <div>
                    <h2>AutoTrader Logs</h2>
                    <p>Realtime feed of recorder events</p>
                </div>
                <span class="status-dot connected">Connected</span>
            </header>
            <div class="log-feed">
                {% for log in logs %}
                <div class="log-entry">
                    <span class="log-type {{ log.type }}">[{{ log.type | upper }}]</span>
                    <span class="log-content">{{ log.message }}</span>
                    <span class="log-time">{{ log.time }}</span>
                </div>
                {% endfor %}
            </div>
        </article>
    </section>
    
</div>
{% endblock %}
{% block styles %}
<style>
    .control-center { display: grid; gap: 1.5rem; }

    .live-panels { display: grid; grid-template-columns: 2fr 1fr; gap: 1.5rem; }
    .live-trading { background: rgba(7,12,23,0.92); border-radius: 18px; border: 1px solid rgba(148,163,184,0.12); overflow: hidden; display: flex; flex-direction: column; }
    .live-trading header { background: rgba(15,23,42,0.75); padding: 1rem 1.25rem; display: flex; justify-content: space-between; align-items: center; gap: 1rem; flex-wrap: wrap; }
    .live-trading h2 { margin: 0; font-size: 1.2rem; }
    
    /* Improved Panel Action Buttons */
    .panel-actions { display: flex; gap: 0.5rem; flex-wrap: wrap; }
    .panel-actions .btn {
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;
        padding: 0.5rem 1rem;
        border-radius: 10px;
        font-size: 0.8rem;
        font-weight: 600;
        letter-spacing: 0.04em;
        text-transform: uppercase;
        cursor: pointer;
        border: none;
        transition: all 0.2s ease;
    }
    .panel-actions .btn .material-icons { font-size: 1rem; }
    .btn-danger { 
        background: linear-gradient(135deg, rgba(239,68,68,0.9), rgba(220,38,38,0.9)); 
        color: #fff;
        box-shadow: 0 2px 8px rgba(239,68,68,0.3);
    }
    .btn-danger:hover { 
        background: linear-gradient(135deg, rgba(248,113,113,1), rgba(239,68,68,1));
        transform: translateY(-1px);
    }
    .btn-warning { 
        background: linear-gradient(135deg, rgba(234,179,8,0.9), rgba(202,138,4,0.9)); 
        color: #0b1120;
        box-shadow: 0 2px 8px rgba(234,179,8,0.3);
    }
    .btn-warning:hover { 
        background: linear-gradient(135deg, rgba(250,204,21,1), rgba(234,179,8,1));
        transform: translateY(-1px);
    }
    .btn-outline { 
        background: rgba(15,23,42,0.6); 
        color: #e2e8f0; 
        border: 1px solid rgba(148,163,184,0.3);
    }
    .btn-outline:hover {
        background: rgba(59,130,246,0.15);
        border-color: rgba(59,130,246,0.5);
        color: #93c5fd;
    }
    
    /* Table Container */
    .table-container { flex: 1; overflow-x: auto; }
    table { width: 100%; border-collapse: collapse; min-width: 500px; }
    thead th { text-align: left; padding: 0.85rem 1.25rem; text-transform: uppercase; letter-spacing: 0.08em; font-size: 0.75rem; color: #94a3b8; border-bottom: 1px solid rgba(148,163,184,0.12); background: rgba(15,23,42,0.4); }
    tbody td { padding: 1rem 1.25rem; border-bottom: 1px solid rgba(148,163,184,0.08); color: #e2e8f0; vertical-align: middle; }
    tbody tr:last-child td { border-bottom: none; }
    tbody tr:hover { background: rgba(59,130,246,0.05); }
    
    .loading-state, .empty-state {
        text-align: center;
        padding: 2rem !important;
        color: #64748b;
    }
    .loading-state .material-icons { margin-right: 0.5rem; vertical-align: middle; }
    .spin { animation: spin 1s linear infinite; }
    @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
    
    /* Strategy cell */
    .strategy-cell { display: flex; flex-direction: column; gap: 0.25rem; }
    .strategy-name { color: #60a5fa; font-weight: 600; text-decoration: none; }
    .strategy-name:hover { text-decoration: underline; }
    .strategy-accounts { font-size: 0.75rem; color: #64748b; }
    
    /* Status cell */
    .status-cell { display: flex; align-items: center; gap: 0.75rem; }
    .status-badge { 
        padding: 0.25rem 0.6rem; 
        border-radius: 999px; 
        font-size: 0.7rem; 
        font-weight: 600; 
        letter-spacing: 0.05em; 
        text-transform: uppercase;
    }
    .status-badge.live { background: rgba(16,185,129,0.2); color: #10b981; border: 1px solid rgba(16,185,129,0.3); }
    .status-badge.paused { background: rgba(234,179,8,0.15); color: #facc15; border: 1px solid rgba(234,179,8,0.3); }
    .status-badge.partial { background: rgba(59,130,246,0.15); color: #60a5fa; border: 1px solid rgba(59,130,246,0.3); }
    
    /* Individual account status indicators */
    .account-status-item { 
        display: inline-flex; 
        align-items: center; 
        gap: 0.25rem; 
        margin-right: 0.5rem;
        font-size: 0.75rem;
        white-space: nowrap;
    }
    .strategy-accounts {
        display: flex;
        flex-wrap: wrap;
        gap: 0.25rem;
        margin-top: 0.35rem;
    }
    
    .switch { position: relative; display: inline-block; width: 44px; height: 22px; flex-shrink: 0; }
    .switch input { opacity: 0; width: 0; height: 0; }
    .slider { position: absolute; inset: 0; background: rgba(148,163,184,0.3); border-radius: 24px; transition: 0.2s; cursor: pointer; }
    .slider:before { content: ""; position: absolute; height: 16px; width: 16px; left: 3px; bottom: 3px; background: #0b1120; border-radius: 50%; transition: 0.2s; }
    .switch input:checked + .slider { background: rgba(16,185,129,0.7); }
    .switch input:checked + .slider:before { transform: translateX(22px); }
    
    .pl-cell { font-weight: 600; font-family: 'SF Mono', Monaco, monospace; }
    .pl-cell.positive { color: #34d399; }
    .pl-cell.negative { color: #f87171; }

    /* Time Filter Status */
    .tf-cell { display: flex; flex-direction: column; gap: 0.2rem; }
    .tf-status { display: inline-block; padding: 0.2rem 0.6rem; border-radius: 999px; font-size: 0.7rem; font-weight: 600; letter-spacing: 0.04em; text-transform: uppercase; }
    .tf-status.tf-active { background: rgba(52,211,153,0.15); color: #34d399; border: 1px solid rgba(52,211,153,0.3); }
    .tf-status.tf-blocked { background: rgba(251,191,36,0.15); color: #fbbf24; border: 1px solid rgba(251,191,36,0.3); }
    .tf-status.tf-always { background: rgba(148,163,184,0.1); color: #64748b; border: 1px solid rgba(148,163,184,0.15); }
    .tf-hours { font-size: 0.65rem; color: #64748b; white-space: nowrap; }
    
    .action-cell { display: flex; gap: 0.5rem; flex-wrap: wrap; }
    .btn-small { 
        padding: 0.4rem 0.75rem; 
        font-size: 0.7rem; 
        border-radius: 8px;
        background: rgba(15,23,42,0.6);
        border: 1px solid rgba(148,163,184,0.2);
        color: #94a3b8;
        cursor: pointer;
        transition: all 0.2s ease;
    }
    .btn-small:hover {
        background: rgba(59,130,246,0.15);
        border-color: rgba(59,130,246,0.4);
        color: #93c5fd;
    }
    .btn-small.btn-close:hover {
        background: rgba(239,68,68,0.15);
        border-color: rgba(239,68,68,0.4);
        color: #fca5a5;
    }

    .autotrader-logs { background: rgba(11,18,33,0.92); border-radius: 18px; border: 1px solid rgba(148,163,184,0.12); display: flex; flex-direction: column; max-height: 600px; }
    .autotrader-logs header { padding: 1rem 1.25rem; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid rgba(148,163,184,0.1); }
    .autotrader-logs h2 { margin: 0; font-size: 1.2rem; }
    .autotrader-logs p { margin: 0; color: var(--text-muted); font-size: 0.85rem; }
    .status-dot { font-size: 0.75rem; letter-spacing: 0.08em; text-transform: uppercase; padding: 0.3rem 0.75rem; border-radius: 999px; }
    .status-dot.connected { background: rgba(52,211,153,0.25); color: #bbf7d0; }
    .status-dot.disconnected { background: rgba(239,68,68,0.2); color: #fca5a5; }
    .log-feed { padding: 1rem 1.25rem; overflow-y: auto; flex: 1; display: flex; flex-direction: column; gap: 0.6rem; }
    .log-entry { background: rgba(15,23,42,0.6); border: 1px solid rgba(59,130,246,0.15); border-radius: 10px; padding: 0.65rem 0.85rem; display: grid; grid-template-columns: auto 1fr auto; gap: 0.5rem; align-items: center; font-size: 0.8rem; }
    .log-type { font-weight: 600; padding: 0.15rem 0.5rem; border-radius: 4px; font-size: 0.7rem; text-transform: uppercase; }
    .log-type.open { background: rgba(16,185,129,0.2); color: #34d399; }
    .log-type.close { background: rgba(251,146,60,0.2); color: #fb923c; }
    .log-type.trade { background: rgba(59,130,246,0.2); color: #60a5fa; }
    .log-content { color: #e2e8f0; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .log-time { color: #64748b; font-size: 0.7rem; white-space: nowrap; }

    /* ============================================
       LIVE POSITIONS SECTION - Trade Manager Style
       ============================================ */
    .live-positions-section { margin-top: 1.5rem; }
    .live-positions-panel {
        background: rgba(7,12,23,0.92);
        border-radius: 18px;
        border: 1px solid rgba(148,163,184,0.12);
        overflow: hidden;
    }
    .live-positions-panel header {
        background: linear-gradient(135deg, rgba(15,23,42,0.9), rgba(30,41,59,0.8));
        padding: 1rem 1.25rem;
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-bottom: 1px solid rgba(59,130,246,0.2);
    }
    .live-positions-panel h2 { margin: 0; font-size: 1.1rem; color: #60a5fa; }
    .live-positions-panel p { margin: 0.25rem 0 0; font-size: 0.75rem; color: #64748b; }
    .price-source {
        background: linear-gradient(135deg, rgba(34,197,94,0.2), rgba(22,163,74,0.15));
        color: #22c55e;
        padding: 0.35rem 0.75rem;
        border-radius: 999px;
        font-size: 0.7rem;
        font-weight: 600;
        letter-spacing: 0.05em;
        border: 1px solid rgba(34,197,94,0.3);
    }
    
    .positions-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
        gap: 1rem;
        padding: 1.25rem;
    }
    
    .no-positions {
        grid-column: 1 / -1;
        text-align: center;
        padding: 2rem;
        color: #64748b;
    }
    .no-positions .material-icons { font-size: 2.5rem; opacity: 0.5; margin-bottom: 0.5rem; }
    .no-positions p { margin: 0; }
    
    /* Position Card */
    .position-card {
        background: linear-gradient(145deg, rgba(15,23,42,0.95), rgba(30,41,59,0.85));
        border-radius: 14px;
        border: 1px solid rgba(148,163,184,0.1);
        overflow: hidden;
        transition: all 0.3s ease;
    }
    .position-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 25px rgba(0,0,0,0.3);
        border-color: rgba(59,130,246,0.3);
    }
    .position-card.positive { border-left: 3px solid #22c55e; }
    .position-card.negative { border-left: 3px solid #ef4444; }
    
    .position-card-header {
        padding: 0.85rem 1rem;
        display: flex;
        justify-content: space-between;
        align-items: center;
        background: rgba(0,0,0,0.2);
        border-bottom: 1px solid rgba(148,163,184,0.08);
    }
    .position-symbol {
        font-weight: 700;
        font-size: 1rem;
        color: #f1f5f9;
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }
    .position-side {
        font-size: 0.65rem;
        font-weight: 600;
        padding: 0.2rem 0.5rem;
        border-radius: 4px;
        text-transform: uppercase;
    }
    .position-side.long { background: rgba(34,197,94,0.2); color: #22c55e; }
    .position-side.short { background: rgba(239,68,68,0.2); color: #ef4444; }
    .position-strategy {
        font-size: 0.7rem;
        color: #60a5fa;
        font-weight: 500;
    }
    
    .position-card-body { padding: 1rem; }
    
    /* Live P&L Display */
    .pnl-display {
        text-align: center;
        padding: 0.75rem;
        background: rgba(0,0,0,0.25);
        border-radius: 10px;
        margin-bottom: 0.85rem;
    }
    .pnl-amount {
        font-size: 1.6rem;
        font-weight: 700;
        font-family: 'JetBrains Mono', monospace;
    }
    .pnl-amount.positive { color: #22c55e; text-shadow: 0 0 20px rgba(34,197,94,0.4); }
    .pnl-amount.negative { color: #ef4444; text-shadow: 0 0 20px rgba(239,68,68,0.4); }
    .pnl-ticks {
        font-size: 0.75rem;
        color: #94a3b8;
        margin-top: 0.25rem;
    }
    
    /* Position Details */
    .position-details {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 0.6rem;
    }
    .detail-item {
        display: flex;
        flex-direction: column;
        gap: 0.15rem;
    }
    .detail-label {
        font-size: 0.65rem;
        color: #64748b;
        text-transform: uppercase;
        letter-spacing: 0.05em;
    }
    .detail-value {
        font-size: 0.85rem;
        color: #e2e8f0;
        font-weight: 500;
        font-family: 'JetBrains Mono', monospace;
    }
    .detail-value.price-live {
        color: #fbbf24;
        animation: pricePulse 1s ease-in-out infinite;
    }
    @keyframes pricePulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.7; }
    }
    
    /* Drawdown indicator */
    .drawdown-bar {
        margin-top: 0.75rem;
        padding-top: 0.75rem;
        border-top: 1px solid rgba(148,163,184,0.1);
    }
    .drawdown-label {
        display: flex;
        justify-content: space-between;
        font-size: 0.7rem;
        margin-bottom: 0.35rem;
    }
    .drawdown-label span:first-child { color: #64748b; }
    .drawdown-label span:last-child { color: #ef4444; font-weight: 600; }
    .drawdown-progress {
        height: 4px;
        background: rgba(239,68,68,0.2);
        border-radius: 2px;
        overflow: hidden;
    }
    .drawdown-fill {
        height: 100%;
        background: linear-gradient(90deg, #ef4444, #dc2626);
        border-radius: 2px;
        transition: width 0.3s ease;
    }

    @media (max-width: 1100px) {
        .live-panels { grid-template-columns: 1fr; }
    }
    @media (max-width: 600px) {
        .panel-actions { width: 100%; justify-content: center; }
        .panel-actions .btn { flex: 1; justify-content: center; }
        .positions-grid { grid-template-columns: 1fr; }
    }

    /* ===== LIGHT MODE OVERRIDES ===== */
    :root[data-theme="light"] .live-trading,
    :root[data-theme="light"] .autotrader-logs,
    :root[data-theme="light"] .live-positions-panel {
        background: #ffffff !important;
        border-color: rgba(148, 163, 184, 0.2) !important;
    }
    :root[data-theme="light"] .live-trading header,
    :root[data-theme="light"] .autotrader-logs header,
    :root[data-theme="light"] .live-positions-panel header {
        background: #f8fafc !important;
    }
    :root[data-theme="light"] .live-trading h2,
    :root[data-theme="light"] .autotrader-logs h2,
    :root[data-theme="light"] .live-positions-panel h2,
    :root[data-theme="light"] .control-center h2 {
        color: #1e293b !important;
    }
    :root[data-theme="light"] .autotrader-logs p,
    :root[data-theme="light"] .live-positions-panel p {
        color: #64748b !important;
    }
    :root[data-theme="light"] thead th {
        background: #f1f5f9 !important;
        color: #475569 !important;
        border-color: rgba(148, 163, 184, 0.2) !important;
    }
    :root[data-theme="light"] tbody td {
        color: #1e293b !important;
        border-color: rgba(148, 163, 184, 0.15) !important;
    }
    :root[data-theme="light"] tbody tr:hover {
        background: rgba(148, 163, 184, 0.1) !important;
    }
    :root[data-theme="light"] .loading-state {
        color: #64748b !important;
    }
    :root[data-theme="light"] .btn-outline {
        background: #f1f5f9 !important;
        color: #1e293b !important;
        border-color: rgba(148, 163, 184, 0.3) !important;
    }
    :root[data-theme="light"] .btn-outline:hover {
        background: #e2e8f0 !important;
    }
    :root[data-theme="light"] .strategy-name {
        color: #0284c7 !important;
    }
    :root[data-theme="light"] .strategy-accounts {
        color: #64748b !important;
    }
    :root[data-theme="light"] .log-entry {
        background: #f8fafc !important;
        border-color: rgba(148, 163, 184, 0.2) !important;
    }
    :root[data-theme="light"] .log-content {
        color: #1e293b !important;
    }
    :root[data-theme="light"] .log-time {
        color: #64748b !important;
    }
    :root[data-theme="light"] .no-positions,
    :root[data-theme="light"] .no-positions p {
        color: #64748b !important;
    }
    :root[data-theme="light"] .position-card {
        background: #ffffff !important;
        border-color: rgba(148, 163, 184, 0.2) !important;
    }
    :root[data-theme="light"] .position-card:hover {
        border-color: rgba(59, 130, 246, 0.4) !important;
    }
    :root[data-theme="light"] .position-symbol {
        color: #0284c7 !important;
    }
    :root[data-theme="light"] .position-account {
        color: #64748b !important;
    }
    :root[data-theme="light"] .position-qty,
    :root[data-theme="light"] .position-entry,
    :root[data-theme="light"] .position-current {
        color: #1e293b !important;
    }
    :root[data-theme="light"] .position-entry span,
    :root[data-theme="light"] .position-current span {
        color: #64748b !important;
    }
    :root[data-theme="light"] .slider {
        background: rgba(148, 163, 184, 0.4) !important;
    }
    :root[data-theme="light"] .slider:before {
        background: #ffffff !important;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
    }
    :root[data-theme="light"] .price-source {
        background: rgba(34, 197, 94, 0.15) !important;
        color: #15803d !important;
    }
</style>
{% endblock %}
{% block scripts %}
<script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
<script>
    document.addEventListener('DOMContentLoaded', function () {
        document.querySelectorAll('.log-feed').forEach(function(feed) {
            feed.scrollTop = feed.scrollHeight;
        });
        
        // Refresh stats periodically
        loadControlCenterStats();
        setInterval(loadControlCenterStats, 30000);  // Refresh every 30 seconds (trades are priority, PnL is secondary)
        
        // WebSocket connection for real-time updates (like Trade Manager)
        const socket = io();
        
        socket.on('connect', () => {
            console.log('Connected to WebSocket');
            const statusDot = document.querySelector('.status-dot');
            if (statusDot) {
                statusDot.textContent = 'Connected';
                statusDot.classList.add('connected');
            }
        });
        
        socket.on('disconnect', () => {
            console.log('Disconnected from WebSocket');
            const statusDot = document.querySelector('.status-dot');
            if (statusDot) {
                statusDot.textContent = 'Disconnected';
                statusDot.classList.remove('connected');
            }
        });
        
        // Signal received - update logs immediately
        socket.on('signal_received', (data) => {
            console.log('Signal received:', data);
            const tradeInfo = data.trade ? ` ‚Üí ${data.trade.action.toUpperCase()} ${data.trade.side || ''}` : '';
            addLogEntry(
                data.action === 'BUY' ? 'open' : 'close',
                `${data.recorder_name}: ${data.action} ${data.ticker} @ ${data.price}${tradeInfo}`,
                data.timestamp
            );
            // Refresh stats to update PnL
            loadControlCenterStats();
        });
        
        // Trade executed
        socket.on('trade_executed', (data) => {
            console.log('Trade executed:', data);
            const pnlStr = data.pnl ? ` | PnL: $${data.pnl.toFixed(2)}` : '';
            addLogEntry('trade', `${data.recorder_name}: ${data.side} closed ${data.ticker}${pnlStr}`, data.timestamp);
            // Refresh stats to update PnL
            loadControlCenterStats();
        });
        
        // Legacy handlers
        socket.on('pnl_update', (data) => {
            loadControlCenterStats();
        });
        
        socket.on('strategy_pnl_update', (data) => {
            // Time filter status replaces P&L column ‚Äî reload stats to refresh
            loadControlCenterStats();
        });
        
        // SCALABILITY MODULE: Real-time PnL from WebSocket (via LegacyBridge)
        // This replaces REST polling with instant WebSocket updates
        socket.on('position_update', (data) => {
            console.log('üì° Scalability position_update:', data);
            if (data.pnl_data) {
                // Update PnL display directly from WebSocket data
                updatePnLFromWebSocket(data.pnl_data);
            }
            if (data.positions && data.positions.length > 0) {
                // Update positions display
                updatePositionsFromWebSocket(data.positions);
            }
        });
        
        // ============================================
        // LIVE POSITION UPDATES - Trade Manager Style
        // Real-time P&L from TradingView price stream
        // ============================================
        
        // Individual position update (every tick)
        socket.on('live_position_update', (data) => {
            console.log('Live position update:', data);
            updatePositionCard(data);
        });
        
        // All positions summary (every second)
        socket.on('live_positions_all', (data) => {
            console.log('üìä Live positions all:', data);
            // Debug: Sum P&L by recorder for comparison
            if (data.positions && data.positions.length > 0) {
                const pnlByRecorder = {};
                data.positions.forEach(pos => {
                    const rid = pos.recorder_id;
                    if (!pnlByRecorder[rid]) {
                        pnlByRecorder[rid] = { name: pos.recorder_name, total: 0, positions: [] };
                    }
                    pnlByRecorder[rid].total += pos.unrealized_pnl || 0;
                    pnlByRecorder[rid].positions.push({
                        ticker: pos.ticker,
                        pnl: pos.unrealized_pnl
                    });
                });
                console.log('üìä Live Positions P&L by Recorder:', pnlByRecorder);
            }
            updateAllPositionCards(data.positions);
        });
        
        function updatePositionCard(pos) {
            const grid = document.getElementById('livePositionsGrid');
            if (!grid) return;
            
            // Find or create position card
            let card = document.getElementById(`position-${pos.position_id}`);
            
            if (!card) {
                // Create new card
                card = document.createElement('div');
                card.id = `position-${pos.position_id}`;
                card.className = 'position-card';
                
                // Remove "no positions" message if present
                const noPos = grid.querySelector('.no-positions');
                if (noPos) noPos.remove();
                
                grid.appendChild(card);
            }
            
            // Determine P&L class
            const pnlClass = pos.unrealized_pnl >= 0 ? 'positive' : 'negative';
            const pnlSign = pos.unrealized_pnl >= 0 ? '+' : '-';
            const ticksSign = pos.pnl_ticks >= 0 ? '+' : '';
            
            // Calculate drawdown percentage (for bar)
            const maxDrawdown = 500; // $500 reference for bar
            const ddPercent = Math.min((pos.drawdown / maxDrawdown) * 100, 100);
            
            card.className = `position-card ${pnlClass}`;
            card.innerHTML = `
                <div class="position-card-header">
                    <div class="position-symbol">
                        ${pos.ticker}
                        <span class="position-side ${pos.side.toLowerCase()}">${pos.side}</span>
                    </div>
                    <span class="position-strategy">${pos.recorder_name}</span>
                </div>
                <div class="position-card-body">
                    <div class="pnl-display">
                        <div class="pnl-amount ${pnlClass}">${pnlSign}$${Math.abs(pos.unrealized_pnl).toFixed(2)}</div>
                        <div class="pnl-ticks">${ticksSign}${pos.pnl_ticks} ticks</div>
                    </div>
                    <div class="position-details">
                        <div class="detail-item">
                            <span class="detail-label">Entry</span>
                            <span class="detail-value">${pos.entry_price.toFixed(2)}</span>
                        </div>
                        <div class="detail-item">
                            <span class="detail-label">Current</span>
                            <span class="detail-value price-live">${pos.current_price.toFixed(2)}</span>
                        </div>
                        <div class="detail-item">
                            <span class="detail-label">Quantity</span>
                            <span class="detail-value">${pos.quantity}</span>
                        </div>
                        <div class="detail-item">
                            <span class="detail-label">Max Profit</span>
                            <span class="detail-value" style="color: #22c55e;">$${pos.max_favorable.toFixed(2)}</span>
                        </div>
                    </div>
                    <div class="drawdown-bar">
                        <div class="drawdown-label">
                            <span>Drawdown</span>
                            <span>-$${pos.drawdown.toFixed(2)}</span>
                        </div>
                        <div class="drawdown-progress">
                            <div class="drawdown-fill" style="width: ${ddPercent}%;"></div>
                        </div>
                    </div>
                </div>
            `;
        }
        
        function updateAllPositionCards(positions) {
            const grid = document.getElementById('livePositionsGrid');
            if (!grid) return;
            
            if (!positions || positions.length === 0) {
                grid.innerHTML = `
                    <div class="no-positions">
                        <span class="material-icons">trending_flat</span>
                        <p>No open positions</p>
                    </div>
                `;
                return;
            }
            
            // Update each position
            positions.forEach(pos => {
                updatePositionCard(pos);
            });
            
            // Remove cards for closed positions
            const existingCards = grid.querySelectorAll('.position-card');
            const activeIds = new Set(positions.map(p => `position-${p.position_id}`));
            existingCards.forEach(card => {
                if (!activeIds.has(card.id)) {
                    card.remove();
                }
            });
            
            // Show "no positions" if all removed
            if (grid.children.length === 0) {
                grid.innerHTML = `
                    <div class="no-positions">
                        <span class="material-icons">trending_flat</span>
                        <p>No open positions</p>
                    </div>
                `;
            }
        }
        
        async function loadControlCenterStats() {
            try {
                // Load traders for CURRENT USER only (filtered by user_id on backend)
                const response = await fetch('/api/traders');
                const data = await response.json();
                
                if (data.success && data.traders) {
                    // Group traders by strategy (recorder) - shows YOUR accounts per strategy
                    const strategyMap = new Map();
                    data.traders.forEach(trader => {
                        const key = trader.recorder_id;
                        if (!strategyMap.has(key)) {
                            strategyMap.set(key, {
                                id: trader.recorder_id,
                                name: trader.recorder_name,
                                traders: [],
                                enabled: false,
                                pnl: 0
                            });
                        }
                        const strategy = strategyMap.get(key);
                        strategy.traders.push(trader);
                        if (trader.enabled) strategy.enabled = true;
                    });
                    
                    // Also fetch PnL data
                    try {
                        const pnlResponse = await fetch('/api/control-center/stats');
                        const pnlData = await pnlResponse.json();
                        if (pnlData.success && pnlData.recorders) {
                            console.log('üìä Control Center Stats Response:', pnlData);
                            pnlData.recorders.forEach(rec => {
                                if (strategyMap.has(rec.id)) {
                                    const s = strategyMap.get(rec.id);
                                    s.pnl = rec.pnl || 0;
                                    s.time_filter_1_enabled = rec.time_filter_1_enabled || false;
                                    s.time_filter_1_start = rec.time_filter_1_start || '';
                                    s.time_filter_1_stop = rec.time_filter_1_stop || '';
                                    s.time_filter_2_enabled = rec.time_filter_2_enabled || false;
                                    s.time_filter_2_start = rec.time_filter_2_start || '';
                                    s.time_filter_2_stop = rec.time_filter_2_stop || '';
                                }
                            });
                        }
                    } catch (e) {
                        console.warn('Could not fetch PnL data:', e);
                    }
                    
                    updateLiveTradingTable(Array.from(strategyMap.values()));
                } else {
                    updateLiveTradingTable([]);
                }
            } catch (error) {
                console.error('Error loading control center stats:', error);
                updateLiveTradingTable([]);
            }
        }
        
        function updateLiveTradingTable(strategies) {
            const tbody = document.getElementById('tradersTableBody');
            if (!tbody) return;
            
            if (strategies.length === 0) {
                tbody.innerHTML = '<tr><td colspan="4" class="empty-state">No active traders. <a href="/traders/new" style="color: #60a5fa;">Create a trader</a> to link a strategy to your accounts.</td></tr>';
                return;
            }
            
            // Build rows - ONE ROW PER STRATEGY (grouped by recorder, YOUR accounts only)
            // Show INDIVIDUAL account status (not just strategy-level)
            let html = '';
            strategies.forEach(strategy => {
                // Time filter status
                const tf = getTimeFilterStatus(strategy);

                // Count enabled vs total traders
                const enabledCount = strategy.traders.filter(t => t.enabled).length;
                const totalCount = strategy.traders.length;
                const allEnabled = enabledCount === totalCount;
                const noneEnabled = enabledCount === 0;

                // Strategy-level status based on accounts
                const statusClass = noneEnabled ? 'paused' : (allEnabled ? 'live' : 'partial');
                const statusText = noneEnabled ? 'PAUSED' : (allEnabled ? 'LIVE' : `${enabledCount}/${totalCount} LIVE`);

                // List YOUR accounts with individual status indicators
                const accountsHtml = strategy.traders.map(t => {
                    const name = t.subaccount_name || t.account_name;
                    const isEnabled = t.enabled;
                    const statusDot = isEnabled ? 'üü¢' : 'üî¥';
                    return `<span class="account-status-item" title="${name}: ${isEnabled ? 'LIVE' : 'PAUSED'}">${statusDot} ${name}</span>`;
                }).join(' ');

                // Build time filter cell content
                const tfHtml = tf.configured
                    ? `<div class="tf-cell"><span class="tf-status ${tf.cssClass}">${tf.label}</span><span class="tf-hours">${tf.hours}</span></div>`
                    : `<div class="tf-cell"><span class="tf-status tf-always">Always On</span></div>`;

                html += `
                    <tr data-strategy-id="${strategy.id}">
                        <td class="strategy-cell">
                            <a href="/recorders/${strategy.id}" class="strategy-name">${strategy.name}</a>
                            <div class="strategy-accounts">${accountsHtml}</div>
                        </td>
                        <td class="status-cell">
                            <span class="status-badge ${statusClass}">${statusText}</span>
                            <label class="switch" title="Toggle ALL accounts for this strategy">
                                <input type="checkbox" ${strategy.enabled ? 'checked' : ''} onchange="toggleStrategy(${strategy.id}, this.checked)">
                                <span class="slider"></span>
                            </label>
                        </td>
                        <td>${tfHtml}</td>
                        <td class="action-cell">
                            <button class="btn-small btn-close" onclick="closeStrategyPositions(${strategy.id}, '${strategy.name}')">Close</button>
                            <button class="btn-small" onclick="viewStrategyDetails(${strategy.id})">View</button>
                        </td>
                    </tr>
                `;
            });
            
            tbody.innerHTML = html;
        }
        
        // Parse "8:45 AM" style time string into minutes since midnight
        function parseTimeToMinutes(timeStr) {
            if (!timeStr) return null;
            const match = timeStr.trim().match(/^(\d{1,2}):(\d{2})\s*(AM|PM)$/i);
            if (!match) return null;
            let hours = parseInt(match[1]);
            const mins = parseInt(match[2]);
            const ampm = match[3].toUpperCase();
            if (ampm === 'PM' && hours !== 12) hours += 12;
            if (ampm === 'AM' && hours === 12) hours = 0;
            return hours * 60 + mins;
        }

        // Get current time in Chicago (Central) timezone as minutes since midnight
        function getChicagoMinutes() {
            const now = new Date();
            const chicagoStr = now.toLocaleString('en-US', { timeZone: 'America/Chicago', hour12: false, hour: '2-digit', minute: '2-digit' });
            const [h, m] = chicagoStr.split(':').map(Number);
            return h * 60 + m;
        }

        // Determine time filter status for a strategy
        // Mirrors engine logic in recorder_service.py lines 1156-1194
        function getTimeFilterStatus(strategy) {
            const s1 = strategy.time_filter_1_start || '';
            const e1 = strategy.time_filter_1_stop || '';
            const s2 = strategy.time_filter_2_start || '';
            const e2 = strategy.time_filter_2_stop || '';

            // Engine: has_trader_time_1 = enabled AND start AND stop
            const hasWindow1 = strategy.time_filter_1_enabled && s1 && e1;
            const hasWindow2 = strategy.time_filter_2_enabled && s2 && e2;

            // Engine: only enters time check if (has_time_1 or has_time_2)
            if (!hasWindow1 && !hasWindow2) {
                return { configured: false, label: 'Always On', cssClass: 'tf-always', hours: '' };
            }

            const nowMin = getChicagoMinutes();

            // Engine: in_window checks with overnight support (start > stop)
            function inWindow(startMin, endMin) {
                if (startMin === null || endMin === null) return true; // invalid = allow
                if (startMin <= endMin) {
                    // Normal window: e.g. 8:45 AM ‚Äì 3:00 PM
                    return nowMin >= startMin && nowMin <= endMin;
                } else {
                    // Overnight window: e.g. 6:00 PM ‚Äì 8:00 AM
                    return nowMin >= startMin || nowMin <= endMin;
                }
            }

            // Engine: in_window_1 = in_window(...) if has_time_1 else False
            let inWindow1 = hasWindow1 ? inWindow(parseTimeToMinutes(s1), parseTimeToMinutes(e1)) : false;
            let inWindow2 = hasWindow2 ? inWindow(parseTimeToMinutes(s2), parseTimeToMinutes(e2)) : false;

            // Engine: reject only if BOTH are false (not in_window_1 and not in_window_2)
            const active = inWindow1 || inWindow2;

            let hoursStr = '';
            if (hasWindow1) hoursStr = `${s1} ‚Äì ${e1}`;
            if (hasWindow2) {
                if (hoursStr) hoursStr += ' | ';
                hoursStr += `${s2} ‚Äì ${e2}`;
            }

            return {
                configured: true,
                label: active ? 'Active' : 'Blocked',
                cssClass: active ? 'tf-active' : 'tf-blocked',
                hours: hoursStr
            };
        }
        
        // SCALABILITY: Update PnL display from WebSocket data (real-time, no REST polling)
        function updatePnLFromWebSocket(pnlData) {
            console.log('üì° Updating PnL from WebSocket:', Object.keys(pnlData).length, 'accounts');
            
            // pnlData is keyed by account_id: { account_name, open_pnl, realized_pnl, net_liq, ... }
            Object.entries(pnlData).forEach(([accountId, data]) => {
                // Update any UI elements that show this account's PnL
                const openPnl = data.open_pnl || 0;
                const realizedPnl = data.realized_pnl || 0;
                const totalPnl = openPnl + realizedPnl;
                
                // Find account row in table (if exists)
                const accountRow = document.querySelector(`tr[data-account-id="${accountId}"]`);
                if (accountRow) {
                    const pnlCell = accountRow.querySelector('.pnl-cell, .pl-cell');
                    if (pnlCell) {
                        const pnlFormatted = totalPnl >= 0 ? `+$${totalPnl.toFixed(2)}` : `-$${Math.abs(totalPnl).toFixed(2)}`;
                        pnlCell.textContent = pnlFormatted;
                        pnlCell.className = pnlCell.className.replace(/positive|negative/g, '') + (totalPnl >= 0 ? ' positive' : ' negative');
                    }
                }
                
                // Update summary totals if needed
                updateTotalPnL();
            });
        }
        
        // SCALABILITY: Update positions display from WebSocket data
        function updatePositionsFromWebSocket(positions) {
            console.log('üì° Updating positions from WebSocket:', positions.length, 'positions');
            
            positions.forEach(pos => {
                // Use existing updatePositionCard if it matches format
                if (pos.position_id) {
                    updatePositionCard(pos);
                }
            });
        }
        
        // Helper to update total PnL display
        function updateTotalPnL() {
            // Sum all visible PnL cells
            const pnlCells = document.querySelectorAll('.pl-cell, .pnl-cell');
            let total = 0;
            pnlCells.forEach(cell => {
                const text = cell.textContent.replace(/[^0-9.-]/g, '');
                const val = parseFloat(text) || 0;
                if (cell.textContent.includes('-')) total -= Math.abs(val);
                else total += val;
            });
            
            // Update total display if exists
            const totalEl = document.getElementById('totalPnL');
            if (totalEl) {
                totalEl.textContent = total >= 0 ? `+$${total.toFixed(2)}` : `-$${Math.abs(total).toFixed(2)}`;
                totalEl.className = total >= 0 ? 'positive' : 'negative';
            }
        }

        function addLogEntry(type, message, time) {
            const logFeed = document.querySelector('.log-feed');
            if (logFeed) {
                const logEntry = document.createElement('div');
                logEntry.className = 'log-entry';
                // Format time in Chicago timezone
                let timeStr;
                if (time) {
                    // Handle UTC timestamps from server
                    let utcStr = time;
                    if (!time.endsWith('Z') && !time.includes('+') && !time.includes('-', 10)) {
                        utcStr = time.replace(' ', 'T') + 'Z';
                    }
                    timeStr = new Date(utcStr).toLocaleTimeString('en-US', { timeZone: 'America/Chicago' });
                } else {
                    timeStr = new Date().toLocaleTimeString('en-US', { timeZone: 'America/Chicago' });
                }
                logEntry.innerHTML = `
                    <span class="log-type ${type}">[${type.toUpperCase()}]</span>
                    <span class="log-content">${message}</span>
                    <span class="log-time">${timeStr}</span>
                `;
                logFeed.insertBefore(logEntry, logFeed.firstChild);
                
                // Keep only last 50 entries
                while (logFeed.children.length > 50) {
                    logFeed.removeChild(logFeed.lastChild);
                }
            }
        }
    });
    
    // Global functions for button handlers
    async function toggleStrategy(strategyId, enabled) {
        try {
            // Toggle all YOUR traders for this strategy (per-user control)
            const response = await fetch(`/api/recorders/${strategyId}/toggle-my-traders`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ enabled: enabled })
            });
            const data = await response.json();
            if (data.success) {
                // Update UI immediately
                const row = document.querySelector(`tr[data-strategy-id="${strategyId}"]`);
                if (row) {
                    const badge = row.querySelector('.status-badge');
                    if (badge) {
                        badge.className = `status-badge ${enabled ? 'live' : 'paused'}`;
                        badge.textContent = enabled ? 'LIVE' : 'PAUSED';
                    }
                }
                console.log(`‚úÖ ${data.message}`);
            } else {
                console.error('Failed to toggle strategy:', data.error);
                alert(`‚ùå Error: ${data.error || 'Failed to toggle'}`);
                // Revert checkbox
                loadControlCenterStats();
            }
        } catch (error) {
            console.error('Error toggling strategy:', error);
            loadControlCenterStats();
        }
    }
    
    async function closeAllPositions() {
        if (!confirm('‚ö†Ô∏è Close ALL open positions on ALL accounts for ALL strategies?\n\nThis will execute close orders on the broker.')) {
            return;
        }
        
        const btn = event.target.closest('.btn');
        const originalHTML = btn.innerHTML;
        btn.disabled = true;
        btn.innerHTML = '<span class="material-icons spin">sync</span> Closing...';
        
        try {
            const response = await fetch('/api/control-center/close-all', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            });
            
            const data = await response.json();
            if (data.success) {
                alert(`‚úÖ ${data.message}`);
                loadControlCenterStats();
            } else {
                alert(`‚ùå Error: ${data.error || 'Unknown error'}`);
            }
        } catch (error) {
            console.error('Error closing positions:', error);
            alert('‚ùå Network error. Please try again.');
        } finally {
            btn.disabled = false;
            btn.innerHTML = originalHTML;
        }
    }
    
    async function clearAllTrades() {
        if (!confirm('‚ö†Ô∏è Clear ALL trade records from database?\n\nThis will DELETE all trade records but will NOT close broker positions.\n\nAre you sure?')) {
            return;
        }
        
        const btn = event.target.closest('.btn');
        const originalHTML = btn.innerHTML;
        btn.disabled = true;
        btn.innerHTML = '<span class="material-icons spin">sync</span> Clearing...';
        
        try {
            const response = await fetch('/api/control-center/clear-all', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            });
            
            const data = await response.json();
            if (data.success) {
                alert(`‚úÖ ${data.message}`);
                loadControlCenterStats();
            } else {
                alert(`‚ùå Error: ${data.error || 'Unknown error'}`);
            }
        } catch (error) {
            console.error('Error clearing trades:', error);
            alert('‚ùå Network error. Please try again.');
        } finally {
            btn.disabled = false;
            btn.innerHTML = originalHTML;
        }
    }
    
    async function toggleAllStrategies() {
        // Get current state from first checkbox
        const firstCheckbox = document.querySelector('#tradersTableBody input[type="checkbox"]');
        const currentState = firstCheckbox ? firstCheckbox.checked : false;
        const newState = !currentState;
        
        const btn = document.getElementById('toggleAllBtn');
        const originalHTML = btn.innerHTML;
        btn.disabled = true;
        btn.innerHTML = `<span class="material-icons spin">sync</span> ${newState ? 'Enabling...' : 'Disabling...'}`;
        
        try {
            const response = await fetch('/api/control-center/toggle-all', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ enabled: newState })
            });
            
            const data = await response.json();
            if (data.success) {
                // Update button text
                btn.innerHTML = newState 
                    ? '<span class="material-icons">pause_circle</span> Disable All'
                    : '<span class="material-icons">play_circle</span> Enable All';
                loadControlCenterStats();
            } else {
                alert(`‚ùå Error: ${data.error || 'Unknown error'}`);
                btn.innerHTML = originalHTML;
            }
        } catch (error) {
            console.error('Error toggling strategies:', error);
            alert('‚ùå Network error. Please try again.');
            btn.innerHTML = originalHTML;
        } finally {
            btn.disabled = false;
        }
    }
    
    async function closeStrategyPositions(strategyId, strategyName) {
        if (!confirm(`‚ö†Ô∏è Close all positions for "${strategyName}"?\n\nThis will execute close orders on all accounts linked to this strategy.`)) {
            return;
        }
        
        try {
            const response = await fetch(`/api/recorders/${strategyId}/close-positions`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            });
            
            const data = await response.json();
            if (data.success) {
                alert(`‚úÖ ${data.message || 'Positions closed'}`);
                loadControlCenterStats();
            } else {
                alert(`‚ùå Error: ${data.error || 'Failed to close positions'}`);
            }
        } catch (error) {
            console.error('Error closing positions:', error);
            alert('‚ùå Network error. Please try again.');
        }
    }
    
    function viewStrategyDetails(strategyId) {
        window.location.href = `/recorders/${strategyId}`;
    }
</script>
{% endblock %}
